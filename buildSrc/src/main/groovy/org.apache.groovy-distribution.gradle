import javax.inject.Inject
import org.apache.groovy.gradle.SharedConfiguration

plugins {
    id 'jvm-ecosystem'
    id 'org.apache.groovy-common'
    id 'org.apache.groovy-aggregating-project'
}

def sharedConfiguration = rootProject.extensions.getByType(SharedConfiguration)

configurations {
    distributions {
        canBeConsumed = false
        canBeResolved = false
    }
    distributionsRuntimeClasspath {
        canBeConsumed = false
        canBeResolved = true
        extendsFrom distributions
        attributes {
            attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.LIBRARY))
            attribute(Bundling.BUNDLING_ATTRIBUTE, objects.named(Bundling, Bundling.EXTERNAL))
            attribute(LibraryElements.LIBRARY_ELEMENTS_ATTRIBUTE, objects.named(LibraryElements, LibraryElements.JAR))
            attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage, Usage.JAVA_RUNTIME))
        }
    }
}

dependencies {
    rootProject.allprojects {
        if (pluginManager.hasPlugin('org.apache.groovy-base')) {
            distributions(it)
        }
    }
    // also include optional features from main module
    distributions(project(path: ":", configuration: 'groovyRuntimeElements'))
    distributions(project(":")) {
        capabilities {
            requireCapability 'org.apache.groovy:groovy-xstream-ast'
        }
    }
    distributions(project(":")) {
        capabilities {
            requireCapability 'org.apache.groovy:groovy-gpars'
        }
    }
    distributions(project(":")) {
        capabilities {
            requireCapability 'org.apache.groovy:groovy-grapes'
        }
    }
    distributions(project(":")) {
        capabilities {
            requireCapability 'org.apache.groovy:groovy-logging'
        }
    }
}

def distSpec = copySpec {
    duplicatesStrategy = DuplicatesStrategy.FAIL
    from rootProject.file("licenses/LICENSE-BINZIP")
    from rootProject.file("notices/NOTICE-BINZIP")
    rename '^([A-Z]+)-([^.]*)', '$1'
    into('lib') {
        from(configurations.distributionsRuntimeClasspath) {
            exclude {
                it.file.name.contains('activation') ||
                it.file.name.contains('jaxb-') ||
                it.file.name.contains('livetribe-jsr223') ||
                it.file.name.startsWith('openbeans-') ||
                        it.file.name.startsWith('asm-') ||
                        it.file.name.startsWith('antlr-') ||
                        it.file.name.startsWith('antlr4-') ||
                        it.file.name.startsWith('picocli-')
            }
        }
        from rootProject.file('src/bin/groovy.icns')
    }
    into('lib/extras-jaxb') {
        from(configurations.distributionsRuntimeClasspath) {
            include {
                it.file.name.contains('activation') ||
                        it.file.name.startsWith('jaxb-')
            }
        }
    }
//    if (!rootProject.hasProperty('skipGrooid')) {
//        into('grooid') {
//            from { new File(jar.archivePath.parent, "${jar.baseName}-${jar.version}-grooid.jar") }
//            from {
//                modules()*.jar.collect { j ->
//                    new File(j.archivePath.parent, "${j.baseName}-${j.version}-grooid.jar")
//                }
//            }
//        }
//    }
    into('conf') {
        from rootProject.file('src/conf')
    }
    into('bin') {
        from(rootProject.file('src/bin')) {
            //filter(ReplaceTokens, tokens: [GROOVYJAR: jarjar.archiveName])
            fileMode = 0755
            exclude 'groovy.icns'
        }
        from project(':groovy-docgenerator').file('src/main/resources/org/apache/groovy/docgenerator/groovy.ico')
    }
    into('licenses') {
        from rootProject.file('licenses')
        include 'antlr4-license.txt'
        include 'asm-license.txt'
        include 'hamcrest-license.txt'
        include 'jline2-license.txt'
        include 'jsr166y-license.txt'
        include 'jsr223-license.txt'
        include 'junit4-license.txt'
        include 'junit5-license.txt'
        include 'xstream-license.txt'
    }
}

tasks.register('distBin', Zip) {
    archiveBaseName = 'apache-groovy'
    into("groovy-${project.version}") {
        with distSpec
    }
    allprojects {
        if (project.name in ['groovy', 'groovy-test']) {
            distBin.dependsOn(grooidjar)
        }
    }
}

tasks.register('distDoc', Zip) {
    //dependsOn: doc
    archiveBaseName = 'apache-groovy'
    archiveClassifier = 'docs'
    into("groovy-${project.version}") {
        with docSpec
    }
}

tasks.register('syncDoc', Copy) {
    //dependsOn: doc
    inputs.files javadoc.outputs.files
    inputs.files groovydoc.outputs.files

    destinationDir(file("$buildDir/html"))
    into('api') {
        from javadoc.destinationDir
    }
    into('gapi') {
        from groovydoc.destinationDir
    }
    // groovy-jdk already at the correct place
}

tasks.register('distSrc', Zip) {
    archiveBaseName = 'apache-groovy'
    archiveClassifier = 'src'
    into("groovy-${project.version}")
    with srcSpec
}

tasks.register("installGroovy", Sync) {
    def installDir = sharedConfiguration.installationDirectory.orElse(project.layout.buildDir.file("install"))
    description 'Generates a groovy distribution into an install directory'
    doLast {
        logger.lifecycle "Groovy installed under ${installDir.get()}"
    }
    with distSpec
    into installDir
}

interface Services {
    @Inject
    SoftwareComponentFactory getSoftwareComponentFactory()
}

// The Gradle distribution module isn't a Java library
// so we create a custom publication
def factory = objects.newInstance(Services).softwareComponentFactory
def component = factory.adhoc('groovyDistribution')
components.add(component)

def bin = configurations.create("distributionBinary") {
    canBeConsumed = true
    canBeResolved = false
    attributes {
        attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, "application"))
    }
    outgoing {
        artifacts {
            artifact tasks.named('distBin')
        }
    }
}
component.addVariantsFromConfiguration(bin) {
    mapToOptional()
}

def doc = configurations.create("distributionDocs") {
    canBeConsumed = true
    canBeResolved = false
    attributes {
        attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.DOCUMENTATION))
        attribute(DocsType.DOCS_TYPE_ATTRIBUTE, objects.named(DocsType, DocsType.USER_MANUAL))
    }
    outgoing {
        artifacts {
            artifact tasks.named('distDoc')
        }
    }
}
component.addVariantsFromConfiguration(doc) {
    mapToOptional()
}

def src = configurations.create("distributionSources") {
    canBeConsumed = true
    canBeResolved = false
    attributes {
        attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.DOCUMENTATION))
        attribute(DocsType.DOCS_TYPE_ATTRIBUTE, objects.named(DocsType, DocsType.SOURCES))
    }
    outgoing {
        artifacts {
            artifact tasks.named('distSrc')
        }
    }
}
component.addVariantsFromConfiguration(src) {
    mapToOptional()
}

