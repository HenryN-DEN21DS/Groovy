/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  "License"); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

import org.apache.groovy.gradle.ReleaseInfoGenerator
import com.github.spotbugs.snom.SpotBugsTask
import org.apache.groovy.gradle.CheckstyleHtmlReport

plugins {
    id 'java-library'
    id 'checkstyle'
    id 'com.github.spotbugs'
    id 'org.apache.groovy-common'
    id 'org.apache.groovy-asciidoctor'
}

/**
 * This script defines a conventional plugin for all Java-only modules.
 */
if (sharedConfiguration.hasCodeCoverage.get()) {
    pluginManager.apply(JacocoPlugin)
}

java {
    withSourcesJar()
    withJavadocJar()
}

def generateReleaseInfo = tasks.register("generateReleaseInfo", ReleaseInfoGenerator)

configurations {
    javadocClasspath {
        canBeConsumed = true
        canBeResolved = false
        extendsFrom implementation, runtimeOnly, compileOnly, compileOnlyApi
        attributes {
            attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.LIBRARY))
            attribute(Bundling.BUNDLING_ATTRIBUTE, objects.named(Bundling, Bundling.EXTERNAL))
            attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage, "javadocClasspath"))
        }
        outgoing {
            artifact tasks.named('jar')
        }
    }
    sourcesForAggregation {
        canBeConsumed = true
        canBeResolved = false
        extendsFrom implementation, runtimeOnly
        attributes {
            attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.DOCUMENTATION))
            attribute(Bundling.BUNDLING_ATTRIBUTE, objects.named(Bundling, Bundling.EXTERNAL))
            attribute(DocsType.DOCS_TYPE_ATTRIBUTE, objects.named(DocsType, DocsType.SOURCES))
            attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage, "aggregation"))
        }
        outgoing {
            sourceSets.main.java.srcDirs.each {
                artifact(it)
            }
        }
    }
}

dependencies {
    compileOnly providers.provider { "com.github.spotbugs:spotbugs-annotations:${versions.spotbugsAnnotations}" }
    checkstyle "com.puppycrawl.tools:checkstyle:${versions.checkstyle}"
    spotbugs "com.github.spotbugs:spotbugs:${versions.spotbugs}"
}

tasks.withType(Jar).configureEach {
    metaInf {
        if (file("${projectDir}/LICENSE").exists()) {
            from "${projectDir}/LICENSE"
        } else {
            from("${rootProject.projectDir}/licenses/LICENSE-BASE") {
                rename 'LICENSE-BASE', 'LICENSE'
            }
        }
        if (file("${projectDir}/NOTICE").exists()) {
            from "${projectDir}/NOTICE"
        } else {
            from("${rootProject.projectDir}/notices/NOTICE-BASE") {
                rename 'NOTICE-BASE', 'NOTICE'
            }
        }
        from generateReleaseInfo
    }
    exclude '**/package-info.class'
}

tasks.withType(AbstractCompile).configureEach {
    sourceCompatibility(sharedConfiguration.targetJavaVersion.get())
    targetCompatibility(sharedConfiguration.targetJavaVersion.get())
}

tasks.withType(Javadoc).configureEach {
    options.source = sharedConfiguration.targetJavaVersion.get()
}

tasks.withType(SpotBugsTask).configureEach {
    excludeFilter = rootProject.file("config/spotbugs/exclude.xml")
    ignoreFailures = true
    effort = 'max'
    maxHeapSize = '2g'
    reports {
        xml.enabled = false
        html {
            enabled = true
            stylesheet = 'fancy.xsl'
        }
    }
}

tasks.register("checkstyle") {
    dependsOn tasks.withType(Checkstyle)
}

tasks.withType(Checkstyle).configureEach {
    showViolations = false
    ignoreFailures = true
    configFile = rootProject.file("config/checkstyle/checkstyle.xml")
    configProperties = ['rootProject.projectDir': rootProject.projectDir]
    def reportFile = layout.buildDirectory.file("reports/checkstyle/${name}.xml")
    reports {
        include('**/*.java')
        xml {
            destination reportFile.get().asFile
        }
    }
    def chk = it
    finalizedBy {
        // we use a closure here as a workaround, to preserve task configuration laziness
        tasks.create("${name}Report", CheckstyleHtmlReport) {
            dependsOn chk
            source.from(chk.source)
            configFile = rootProject.file("config/checkstyle/checkstyle-report.groovy")
            checkstyleReportFile = reportFile
            outputFile = layout.buildDirectory.file("reports/checkstyle/${chk.name}.html")
        }
    }
}
