/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  "License"); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */


import groovy.transform.CompileStatic
import org.apache.groovy.gradle.GroovyLibraryExtension
import org.apache.groovy.gradle.JarJarTask
import org.gradle.api.attributes.java.TargetJvmVersion

import javax.inject.Inject

plugins {
    id 'groovy'
    id 'codenarc'
    id 'org.apache.groovy-java-base'
    id 'org.apache.groovy-internal'
    id 'org.apache.groovy-tested'
}

/**
 * This script defines a conventional plugin for all Groovy modules, be it
 * Groovy core or any of its libraries.
 */

def groovyLibrary = project.extensions.create("groovyLibrary", GroovyLibraryExtension, sharedConfiguration, project.convention.plugins.java, java)

def groovydocJar = tasks.register("groovydocJar", Jar) {
    from groovydoc
    archiveClassifier = 'groovydoc'
    group = 'build'
    description = 'Assembles a jar archive containing the main groovydoc.'
}

configurations {
    groovydocElements {
        canBeConsumed = true
        canBeResolved = false
        attributes {
            attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.DOCUMENTATION))
            attribute(Bundling.BUNDLING_ATTRIBUTE, objects.named(Bundling, Bundling.EXTERNAL))
            attribute(DocsType.DOCS_TYPE_ATTRIBUTE, objects.named(DocsType, "groovydoc"))
            attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage, Usage.JAVA_RUNTIME))
        }
        outgoing {
            artifact groovydocJar
        }
    }
    sourcesForAggregation {
        outgoing {
            sourceSets.main.groovy.srcDirs.each {
                artifact(it)
            }
        }
    }
    codenarc {
        resolutionStrategy.dependencySubstitution {
            substitute module("org.codehaus.groovy:groovy") with project(":")
            substitute module("org.codehaus.groovy:groovy-ant") with project(":groovy-ant")
            substitute module("org.codehaus.groovy:groovy-templates") with project(":groovy-templates")
            substitute module("org.codehaus.groovy:groovy-xml") with project(":groovy-xml")
            substitute module("org.codehaus.groovy:groovy-groovydoc") with project(":groovy-groovydoc")
        }

        exclude module: 'groovy-all'
    }
}

dependencies {
    codenarc "org.codenarc:CodeNarc:${versions.codenarc}"
    codenarc project(":groovy-templates")
}

def excludedFromManifest = [
        'Ant-Version',
        'Originally-Created-By',
        'Bnd-LastModified',
        'Created-By'
]

tasks.named('jar') {
    archiveAppendix = 'raw'
    groovyLibrary.configureManifest(manifest, excludedFromManifest)
}

tasks.register("jarjar", JarJarTask) {
    from = jar.archiveFile
    repackagedLibraries.from configurations.runtimeClasspath.incoming.artifactView {
        componentFilter { component ->
            if (component instanceof ModuleComponentIdentifier) {
                return component.module in groovyLibrary.repackagedDependencies.get()
            }
            return false
        }
    }.files
    untouchedFiles = [
            'groovy/cli/picocli/CliBuilder*.class',
            'groovy/cli/picocli/OptionAccessor*.class'
    ]
    patterns = [
            'org.antlr.**': 'groovyjarjarantlr4.@1', // antlr4
            'org.objectweb.**': 'groovyjarjarasm.@1',
            'picocli.**': 'groovyjarjarpicocli.@1'
    ]
    excludesPerLibrary = [
            '*': ['META-INF/maven/**', 'META-INF/*', 'META-INF/services/javax.annotation.processing.Processor', '**/module-info.class']
    ]
    includesPerLibrary = [
            'asm-util': ['org/objectweb/asm/util/Printer.class',
                         'org/objectweb/asm/util/Textifier*',
                         'org/objectweb/asm/util/ASMifier.class',
                         'org/objectweb/asm/util/Trace*']
    ]
    outputFile = tasks.named('jar').flatMap { layout.buildDirectory.file("libs/${it.archiveBaseName.get()}-${it.archiveVersion.get()}${it.archiveClassifier.get() ? '-' + it.archiveClassifier.get() : ''}.jar") }

    withManifest {
        def moduleName = "org.apache.${project.name.replace('-', '.')}"
        attributes('Automatic-Module-Name': moduleName)
        groovyLibrary.configureManifest(it, excludedFromManifest)
        classpath = configurations.runtimeClasspath
    }
}

tasks.named("compileTestGroovy") {
    options.forkOptions.jvmArgs += ["-Dspock.iKnowWhatImDoing.disableGroovyVersionCheck=true"]
}

tasks.withType(CodeNarc).configureEach {
    ignoreFailures = true
    configFile = rootProject.file("config/codenarc/codenarc.groovy")
}

interface Services {
    @Inject
    SoftwareComponentFactory getSoftwareComponentFactory()
}

// Groovy doesn't publish the regular jars: it publishes
// the repackaged jars, which is why we can't use the
// default publication, and need to create our own
def factory = objects.newInstance(Services).softwareComponentFactory
def component = factory.adhoc('groovyLibrary')
components.add(component)

components.groovyLibrary {
    addVariantsFromConfiguration(configurations.groovydocElements) {
        mapToOptional()
    }
    addVariantsFromConfiguration(configurations.javadocElements) {
        mapToOptional()
    }
    addVariantsFromConfiguration(configurations.sourcesElements) {
        mapToOptional()
    }
}

// By declaring a codehaus capability we can tell Gradle that the user has to
// choose between "old" groovy and "new" groovy
List<String> capabilities = [
        "org.codehaus.groovy:${archivesBaseName}:${sharedConfiguration.groovyVersion.get()}",
        "org.apache.groovy:${archivesBaseName}:${sharedConfiguration.groovyVersion.get()}"
]
int targetJvmVersion = Integer.valueOf(sharedConfiguration.targetJavaVersion.get())
// First we create the "API" and "runtime" variants of Groovy for publication
def shadowApi = createConsumableConfiguration(objects, tasks, configurations, 'groovyApiElements', Usage.JAVA_API, 'jarjar', capabilities, targetJvmVersion)
def shadowRuntime = createConsumableConfiguration(objects, tasks, configurations, 'groovyRuntimeElements', Usage.JAVA_RUNTIME, 'jarjar', capabilities, targetJvmVersion)
dependencies {
    // All Groovy modules depend on the Groovy BOM which itself has constraints on all
    // Groovy modules, which brings nice alignment features!
    groovyApiElements platform(project(":groovy-bom"))
    groovyRuntimeElements platform(project(":groovy-bom"))
}
component.addVariantsFromConfiguration(shadowApi) {

}
component.addVariantsFromConfiguration(shadowRuntime) {

}
afterEvaluate {
    def repackaged = groovyLibrary.repackagedDependencies.get()
    if (!repackaged) {
        // only modules which do not repackage dependencies are going to inherit dependencies
        shadowApi.extendsFrom(configurations.api)
        shadowRuntime.extendsFrom(configurations.implementation)
        shadowRuntime.extendsFrom(configurations.runtimeOnly)
    }
}

@CompileStatic
Configuration createConsumableConfiguration(ObjectFactory objects,
                                            TaskContainer tasks,
                                            ConfigurationContainer container,
                                            String name,
                                            String usage,
                                            String artifactTask,
                                            List<String> capabilities,
                                            int targetJvmVersion) {
    container.create(name) { Configuration cnf ->
        cnf.canBeConsumed = true
        cnf.canBeResolved = false
        cnf.attributes {
            it.attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.LIBRARY))
            it.attribute(LibraryElements.LIBRARY_ELEMENTS_ATTRIBUTE, objects.named(LibraryElements, LibraryElements.JAR))
            it.attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage, usage))
            // We use external because only Groovy core actually repackages dependencies
            it.attribute(Bundling.BUNDLING_ATTRIBUTE, objects.named(Bundling, Bundling.EXTERNAL))
            it.attribute(TargetJvmVersion.TARGET_JVM_VERSION_ATTRIBUTE, targetJvmVersion)
        }
        cnf.outgoing {
            it.artifact tasks.named(artifactTask)
            capabilities.each { capability ->
                it.capability(capability)
            }
        }
    }
}