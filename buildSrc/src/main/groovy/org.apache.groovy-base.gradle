/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  "License"); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */


import groovy.transform.CompileStatic
import org.apache.groovy.gradle.GroovyLibraryExtension
import org.apache.groovy.gradle.JarJarTask
import org.apache.groovy.gradle.ReleaseInfoGenerator
import org.gradle.api.attributes.java.TargetJvmVersion

import javax.inject.Inject

plugins {
    id 'java-library'
    id 'groovy'
    id 'org.apache.groovy-common'
    id 'org.apache.groovy-tested'
}

/**
 * This script defines a conventional plugin for all Groovy modules, be it
 * Groovy core or any of its libraries.
 */

def groovyLibrary = project.extensions.create("groovyLibrary", GroovyLibraryExtension, project.objects, sharedConfiguration, project.convention.plugins.java, java, components, configurations)

java {
    withSourcesJar()
    withJavadocJar()
    sourceCompatibility = JavaVersion.VERSION_1_8
    targetCompatibility = JavaVersion.VERSION_1_8
}

def generateReleaseInfo = tasks.register("generateReleaseInfo", ReleaseInfoGenerator)

def groovydocJar = tasks.register("groovydocJar", Jar) {
    from groovydoc
    archiveClassifier = 'groovydoc'
}

def internalPublication = Attribute.of("org.apache.groovy.internal", Boolean)

def makeInternal = { Configuration cnf ->
    cnf.attributes {
        it.attribute(internalPublication, true)
    }
}

configurations {
    makeInternal(apiElements)
    makeInternal(runtimeElements)
    makeInternal(compileClasspath)
    makeInternal(runtimeClasspath)
    makeInternal(testCompileClasspath)
    makeInternal(testRuntimeClasspath)
    pluginManager.withPlugin('java-test-fixtures') {
        makeInternal(testFixturesCompileClasspath)
        makeInternal(testFixturesRuntimeClasspath)
    }
    groovydocElements {
        canBeConsumed = true
        canBeResolved = false
        attributes {
            attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.DOCUMENTATION))
            attribute(Bundling.BUNDLING_ATTRIBUTE, objects.named(Bundling, Bundling.EXTERNAL))
            attribute(DocsType.DOCS_TYPE_ATTRIBUTE, objects.named(DocsType, "groovydoc"))
            attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage, Usage.JAVA_RUNTIME))
        }
        outgoing {
            artifact groovydocJar
        }
    }
    sourcesForAggregation {
        canBeConsumed = true
        canBeResolved = false
        extendsFrom implementation, runtimeOnly
        attributes {
            attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.DOCUMENTATION))
            attribute(Bundling.BUNDLING_ATTRIBUTE, objects.named(Bundling, Bundling.EXTERNAL))
            attribute(DocsType.DOCS_TYPE_ATTRIBUTE, objects.named(DocsType, DocsType.SOURCES))
            attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage, "aggregation"))
        }
        outgoing {
            sourceSets.main.java.srcDirs.each {
                artifact(it)
            }
            sourceSets.main.groovy.srcDirs.each {
                artifact(it)
            }
        }
    }
    javadocClasspath {
        canBeConsumed = true
        canBeResolved = false
        extendsFrom implementation, runtimeOnly, compileOnly, compileOnlyApi
        attributes {
            attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.LIBRARY))
            attribute(Bundling.BUNDLING_ATTRIBUTE, objects.named(Bundling, Bundling.EXTERNAL))
            attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage, "javadocClasspath"))
        }
        outgoing {
            artifact tasks.named('jar')
        }
    }
    groovyCompilerClasspath {
        canBeConsumed = false
        canBeResolved = true
        attributes {
            attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.LIBRARY))
            attribute(LibraryElements.LIBRARY_ELEMENTS_ATTRIBUTE, objects.named(LibraryElements, LibraryElements.JAR))
            attribute(Bundling.BUNDLING_ATTRIBUTE, objects.named(Bundling, Bundling.EXTERNAL))
            attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage, Usage.JAVA_RUNTIME))
            attribute(internalPublication, true)
        }
    }
}

dependencies {
    if (project != rootProject) {
        groovyCompilerClasspath project(":")
    }
    compileOnly providers.provider { "com.github.spotbugs:spotbugs-annotations:${rootProject.ext.spotbugsAnnotationsVersion}" }
}

def excludedFromManifest = [
        'Ant-Version',
        'Originally-Created-By',
        'Bnd-LastModified',
        'Created-By'
]

tasks.named('jar') {
    archiveAppendix = 'raw'
    groovyLibrary.configureManifest(manifest, excludedFromManifest)
}

tasks.withType(Jar) {
    metaInf {
        if (file("${projectDir}/LICENSE").exists()) {
            from "${projectDir}/LICENSE"
        } else {
            from "${rootProject.projectDir}/licenses/LICENSE-BASE"
        }
        if (file("${projectDir}/NOTICE").exists()) {
            from "${projectDir}/NOTICE"
        } else {
            from "${rootProject.projectDir}/notices/NOTICE-BASE"
        }
    }
    exclude '**/package-info.class'
}

tasks.register("jarjar", JarJarTask) {
    from = jar.archiveFile
    repackagedLibraries.from configurations.runtimeClasspath.incoming.artifactView {
        componentFilter { component ->
            if (component instanceof ModuleComponentIdentifier) {
                return component.module in groovyLibrary.repackagedDependencies.get()
            }
            return false
        }
    }.files
    untouchedFiles = [
            'groovy/cli/picocli/CliBuilder*.class',
            'groovy/cli/picocli/OptionAccessor*.class'
    ]
    patterns = [
            'org.antlr.**': 'groovyjarjarantlr4.@1', // antlr4
            'org.objectweb.**': 'groovyjarjarasm.@1',
            'picocli.**': 'groovyjarjarpicocli.@1'
    ]
    excludesPerLibrary = [
            '*': ['META-INF/maven/**', 'META-INF/*', 'META-INF/services/javax.annotation.processing.Processor', '**/module-info.class']
    ]
    includesPerLibrary = [
            'asm-util': ['org/objectweb/asm/util/Printer.class',
                         'org/objectweb/asm/util/Textifier*',
                         'org/objectweb/asm/util/ASMifier.class',
                         'org/objectweb/asm/util/Trace*']
    ]
    outputFile = tasks.named('jar').flatMap { layout.buildDirectory.file("libs/${it.archiveBaseName.get()}-${it.archiveVersion.get()}${it.archiveClassifier.get() ? '-' + it.archiveClassifier.get() : ''}.jar") }

    withManifest {
        def moduleName = "org.apache.${project.name.replace('-', '.')}"
        attributes('Automatic-Module-Name': moduleName)
        groovyLibrary.configureManifest(it, excludedFromManifest)
        classpath = configurations.runtimeClasspath
    }
}

components.java {
    addVariantsFromConfiguration(configurations.groovydocElements) {
        mapToOptional()
    }
}

tasks.withType(AbstractCompile).configureEach {
    options.encoding = 'UTF-8'
}

tasks.withType(GroovyCompile).configureEach {
    groovyOptions.forkOptions.jvmArgs += ["-Dgroovy.antlr4.cache.threshold=100"]
    groovyOptions.fork(memoryMaximumSize: sharedConfiguration.groovycMaxMemory.get())
    groovyClasspath = configurations.groovyCompilerClasspath

    options.incremental = true
}

tasks.named("compileTestGroovy") {
    options.forkOptions.jvmArgs += ["-Dspock.iKnowWhatImDoing.disableGroovyVersionCheck=true"]
}


interface Services {
    @Inject
    SoftwareComponentFactory getSoftwareComponentFactory()
}

// Groovy doesn't publish the regular jars: it publishes
// the repackaged jars, which is why we can't use the
// default publication, and need to create our own
def factory = objects.newInstance(Services).softwareComponentFactory
def component = factory.adhoc('groovyLibrary')
components.add(component)

// By declaring a codehaus capability we can tell Gradle that the user has to
// choose between "old" groovy and "new" groovy
String capability = "org.codehaus.groovy:${archivesBaseName}:${sharedConfiguration.groovyVersion.get()}"

// First we create the "API" and "runtime" variants of Groovy for publication
def shadowApi = createConsumableConfiguration(objects, tasks, configurations, 'groovyApiElements', Usage.JAVA_API, 'jarjar', capability)
def shadowRuntime = createConsumableConfiguration(objects, tasks, configurations, 'groovyRuntimeElements', Usage.JAVA_RUNTIME, 'jarjar', capability)
dependencies {
    constraints {
        // All Groovy modules depend on the "Groovy-all" platform in order to get alignement
        // However because groovy-all doesn't reference all modules this is partial alignement
        groovyApiElements platform(project(":groovy-all"))
        groovyRuntimeElements platform(project(":groovy-all"))
    }
}
component.addVariantsFromConfiguration(shadowApi) {

}
component.addVariantsFromConfiguration(shadowRuntime) {

}
afterEvaluate {
    def repackaged = groovyLibrary.repackagedDependencies.get()
    if (!repackaged) {
        // only modules which do not repackage dependencies are going to inherit dependencies
        shadowApi.extendsFrom(configurations.api)
        shadowRuntime.extendsFrom(configurations.implementation)
        shadowRuntime.extendsFrom(configurations.runtimeOnly)
    }
}

@CompileStatic
Configuration createConsumableConfiguration(ObjectFactory objects,
                                            TaskContainer tasks,
                                            ConfigurationContainer container,
                                            String name,
                                            String usage,
                                            String artifactTask,
                                            String capability) {
    container.create(name) { Configuration cnf ->
        cnf.canBeConsumed = true
        cnf.canBeResolved = false
        cnf.attributes {
            it.attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.LIBRARY))
            it.attribute(LibraryElements.LIBRARY_ELEMENTS_ATTRIBUTE, objects.named(LibraryElements, LibraryElements.JAR))
            it.attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage, usage))
            // We use external because only Groovy core actually repackages dependencies
            it.attribute(Bundling.BUNDLING_ATTRIBUTE, objects.named(Bundling, Bundling.EXTERNAL))
            it.attribute(TargetJvmVersion.TARGET_JVM_VERSION_ATTRIBUTE, 8)
        }
        cnf.outgoing {
            it.artifact tasks.named(artifactTask)
            if (capability) {
                it.capability(capability)
            }
        }
    }
}