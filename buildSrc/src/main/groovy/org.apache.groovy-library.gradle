/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  "License"); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

/**
 * This script defines a conventional plugin for Groovy libraries produced by
 * the build
 */

import org.apache.groovy.gradle.ReleaseInfoGenerator
import org.apache.groovy.gradle.GroovyLibraryExtension

plugins {
    id 'org.apache.groovy-shared-repositories'
    id 'java-library'
    id 'groovy'
    id 'org.apache.groovy-base'
    id 'org.apache.groovy-documented'
    id 'org.apache.groovy-published-library'
}

project.extensions.create("groovyLibrary", GroovyLibraryExtension, project.objects)

java {
    withSourcesJar()
    withJavadocJar()
    sourceCompatibility = JavaVersion.VERSION_1_8
    targetCompatibility = JavaVersion.VERSION_1_8
}

task generateReleaseInfo(type: ReleaseInfoGenerator)

task groovydocJar(type: Jar, dependsOn: groovydoc) {
    from groovydoc.destinationDir
    archiveClassifier = 'groovydoc'
}

configurations {
    groovydocElements {
        canBeConsumed = true
        canBeResolved = false
        attributes {
            attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.DOCUMENTATION))
            attribute(Bundling.BUNDLING_ATTRIBUTE, objects.named(Bundling, Bundling.EXTERNAL))
            attribute(DocsType.DOCS_TYPE_ATTRIBUTE, objects.named(DocsType, "groovydoc"))
            attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage, Usage.JAVA_RUNTIME))
        }
        outgoing {
            artifact groovydocJar
        }
    }
    sourcesForAggregation {
        canBeConsumed = true
        canBeResolved = false
        extendsFrom implementation, runtimeOnly
        attributes {
            attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.DOCUMENTATION))
            attribute(Bundling.BUNDLING_ATTRIBUTE, objects.named(Bundling, Bundling.EXTERNAL))
            attribute(DocsType.DOCS_TYPE_ATTRIBUTE, objects.named(DocsType, DocsType.SOURCES))
            attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage, "aggregation"))
        }
        outgoing {
            sourceSets.main.java.srcDirs.each {
                artifact(it)
            }
            sourceSets.main.groovy.srcDirs.each {
                artifact(it)
            }
        }
    }
    javadocClasspath {
        canBeConsumed = true
        canBeResolved = false
        extendsFrom implementation, runtimeOnly, compileOnly, compileOnlyApi
        attributes {
            attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.LIBRARY))
            attribute(Bundling.BUNDLING_ATTRIBUTE, objects.named(Bundling, Bundling.EXTERNAL))
            attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage, "javadocClasspath"))
        }
        outgoing {
            artifact jar
        }
    }
}

components.java {
    addVariantsFromConfiguration(configurations.groovydocElements) {
        mapToOptional()
    }
}

// TODO: Convert to proper task
task dgmConverter(dependsOn: compileJava) {
    outputs.cacheIf { true }

    description = 'Generates DGM info file required for faster startup.'
    def classpath = files(sourceSets.main.output.classesDirs, configurations.compileClasspath)
    ext.outputDir = file("$buildDir/dgm")

    //main = 'org.codehaus.groovy.tools.DgmConverter'
    //args = ['--info', classesDir.absolutePath]
    doFirst {
        file("$outputDir/META-INF").mkdirs()
        // we use ant.java because Gradle is a bit "too smart" with JavaExec
        // as it will invalidate the task if classpath changes, which will
        // happen once Groovy files are compiled
        ant.java(classname: 'org.codehaus.groovy.tools.DgmConverter', classpath: classpath.asPath) {
            arg(value: '--info')
            arg(value: "$outputDir.absolutePath")
        }
    }
    inputs.files fileTree('src/main').include('**/*GroovyMethods.java')
    outputs.dir outputDir
}

tasks.withType(AbstractCompile).configureEach {
    options.encoding = 'UTF-8'
    //options.compilerArgs << "-Xlint:unchecked" << "-Xlint:deprecation"

    if (classpath) {
        classpath = classpath + files(dgmConverter.outputDir)
    }
}