/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  "License"); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

import org.apache.groovy.gradle.GroovyLibraryExtension

/**
 * "groovy-all" is a platform which has explicit dependencies on most
 * libraries of the Groovy project.
 *
 * It also aggregates docs and sources but does NOT provide an "uber" jar.
 */

plugins {
    id 'org.apache.groovy-platform'
    id 'org.apache.groovy-documented'
    id 'org.apache.groovy-shared-repositories'
}

javaPlatform {
    allowDependencies()
}

def projectsIncludedInGroovyAll = rootProject.allprojects.findAll {
    if (it.pluginManager.hasPlugin('org.apache.groovy-library')) {
        return it.extensions.getByType(GroovyLibraryExtension).includeInGroovyAll.get()
    }
    return false
}

configurations {
    allSources {
        canBeConsumed = false
        canBeResolved = true
        transitive = false
        extendsFrom runtime
        attributes {
            attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.DOCUMENTATION))
            attribute(Bundling.BUNDLING_ATTRIBUTE, objects.named(Bundling, Bundling.EXTERNAL))
            attribute(DocsType.DOCS_TYPE_ATTRIBUTE, objects.named(DocsType, DocsType.SOURCES))
            attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage, "aggregation"))
        }
    }
    allSourcesRuntimeClasspath {
        canBeConsumed = false
        canBeResolved = true
        extendsFrom runtime
        attributes {
            attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.LIBRARY))
            attribute(Bundling.BUNDLING_ATTRIBUTE, objects.named(Bundling, Bundling.EXTERNAL))
            attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage, "javadocClasspath"))
        }
    }
}

dependencies {
    projectsIncludedInGroovyAll.each {
        api(it)
    }
    attributesSchema {
        attribute(Usage.USAGE_ATTRIBUTE) {
            compatibilityRules.add(JavadocClasspathCompatibilityRule)
        }
    }
}

def sourcesAllJar = tasks.register("sourcesAllJar", Jar) {
    from configurations.allSources
    archiveClassifier = 'sources'
}

def javadocAll = tasks.register("javadocAll", Javadoc) {
    destinationDir = file("$buildDir/alljavadoc")
    source configurations.allSources
    classpath = configurations.allSourcesRuntimeClasspath
    exclude '**/*.html'
    exclude '**/*.groovy'
    exclude '**/GroovyRecognizer.java' // generated file
}

def javadocAllJar = tasks.register("javadocAllJar", Jar) {
    from javadocAll
    archiveClassifier = 'javadoc'
}

def groovydocAll = tasks.register("groovydocAll", Groovydoc) {
    destinationDir = file("${buildDir}/allgroovydoc")
    source = configurations.allSources
    classpath = configurations.allSourcesRuntimeClasspath
    //groovyClasspath = groovydoc.groovyClasspath
}

def groovydocAllJar = tasks.register("groovydocAllJar", Jar) {
    from groovydocAll
    archiveClassifier = 'groovydoc'
}

def createDocumentationPublication = { String name, TaskProvider artifact ->
    def outgoing = configurations.create("${name}Elements") {
        it.canBeConsumed = true
        it.canBeResolved = false
        it.attributes {
            it.attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.DOCUMENTATION))
            it.attribute(Bundling.BUNDLING_ATTRIBUTE, objects.named(Bundling, Bundling.EXTERNAL))
            it.attribute(DocsType.DOCS_TYPE_ATTRIBUTE, objects.named(DocsType, name))
            it.attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage, Usage.JAVA_RUNTIME))
        }
        it.outgoing {
            it.artifact artifact
        }
    }
    components.javaPlatform {
        addVariantsFromConfiguration(outgoing) {
            mapToOptional()
        }
    }
}

createDocumentationPublication('sources', sourcesAllJar)
createDocumentationPublication('javadoc', javadocAllJar)
createDocumentationPublication('groovydoc', groovydocAllJar)

class JavadocClasspathCompatibilityRule implements AttributeCompatibilityRule<Usage> {
    @Override
    void execute(CompatibilityCheckDetails<Usage> details) {
        if (details.consumerValue.name == 'javadocClasspath' && details.producerValue.name == Usage.JAVA_RUNTIME) {
            details.compatible()
        }
    }
}